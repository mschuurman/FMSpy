#!/usr/bin/env python
"""
This is the driver for the hamiltonian propagation. This driver
reads the checkpoint file, passes the trajectory data (in batches,
if need be) to the Hamiltonian propagation routines, which
are written as dynamically loaded libraries
"""
import os
import sys as sys
import h5py
import numpy as np
import nomad.core.glbl as glbl
import nomad.core.checkpoint as checkpoint
from ctypes import *

global chkpt_file, ti, tf

def init():
    """Initializes the nomad inputs.

    This must be separate from main so that an error which occurs
    before the input file is created will be written to stdout.
    """

    process_arguments(sys.argv)

def process_arguments(args):
    """Process command line arguments."""
    global chkpt_file, ti, tf

    glbl.paths['cwd']        = os.getcwd()
    glbl.paths['chkpt_file'] = args[1]
    chkpt_file               = args[1]

    if '-ti' in sys.argv:
        ti = float(args[args.index('-ti')+1])
    else:
        ti = float(0.)
    if '-tf' in sys.argv:
        tf = float(args[args.index('-tf')+1])
    else:
        tf = None 
    if '-ansatz' in sys.argv:
        prop_class = args[args.index('-ti')+1]
    else:
        prop_class = 'fms' 
 
    return

def main():
    """ main driver routine """
    global chkpt_file, ti, tf

#    prop_classes = ['fms','mce','mca','ehrenfest']
    prop_classes = ['fms']

    if prop_class not in prop_classes:
        os.exit('prop_class='+prop_class+' is not a valid Hamiltonian type')

    # load the appropriate library
    prop_path = os.enrivon['NOMAD']+'/post/'+prop_class+'.a'
#    if not os.path.isfile(prop_path):
#        raise FileNotFoundError('Hamiltonian library not found: '+prop_path)
#    libprop = cdll.LoadLibrary(prop_path)

    # reset chkpt_file variable to be consistent with the current path
    chkpt = h5py.File(chkpt_file, 'r+', libver='latest')
    checkpoint.write_keyword(chkpt,
                             'keywords_paths',
                             'chkpt_file',
                              chkpt_file)
    checkpoint.read_keywords(chkpt)

    # extract information about the basis
    n_wfn, n_traj, n_steps, t_times = checkpoint.retrieve_basis(chkpt)
#    libprop.init_trajectories(sum(n_traj), 
#                              glbl.properties['crd_widths'], 
#                              glbl.properties['crd_masses'])

    # start processing trajectory data by looping over wavefunction
    # objects and add each trajectory to the dll
    batch = 0
    dsets = ['states','potential','geom','momentum','derivative']
    for wfn_grp in chkpt.keys():
        if 'wavefunction' in wfn_grp:
            batch = batch + 1
            print("\nwfn_grp: "+str(wfn_grp))
            for traj_grp in chkpt[wfn_grp].keys():
                print("\ntraj_grp="+str(traj_grp))
                if checkpoint.isTrajectory(traj_grp):
                    data = [None] * len(dsets)
                    for iset in range(len(dsets)):
                        dset = wfn_grp+"/"+traj_grp+"/"+dsets[iset]
                        t, datum = checkpoint.retrieve_dataset(chkpt,dset,ti,tf)
                        data[iset] = datum
                    args = [batch, t] + data
#                    libprop.add_trajectory(*args)
    chkpt.close()

    # after data is loaded, this is all on the propagation routines
#    libprop.init_propagate()
#    libprop.propagate()


if __name__ == '__main__':
    # parse command line arguments
    if '-openmp' in sys.argv:
        glbl.mpi['parallel'] = True

    # initialize
    init()

    # run the main routine
    main()

