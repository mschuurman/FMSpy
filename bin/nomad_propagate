#!/usr/bin/env python
"""
This is the driver for the hamiltonian propagation. This driver
reads the checkpoint file, passes the trajectory data (in batches,
if need be) to the Hamiltonian propagation routines, which
are written as dynamically loaded libraries
"""
import os
import sys as sys
import h5py as h5py
import ctypes as ctypes
import array as array
import numpy as np
import nomad.core.glbl as glbl
import nomad.core.wavefunction as wavefunction
import nomad.core.checkpoint as checkpoint
import nomad.analysis.lib_utils as lib_utils


chkpt_file    = ''
prop_class    = ''
amp_archive   = ''
ti            = 0.
tf            = 0.
full_basis    = False
t_method      = ''
init_method   = ''
int_method    = ''
int_order     = ''
tstep_methods = ['nascent', 'static']
init_methods  = ['overlap','uniform','explicit']
int_methods   = ['saddle', 'taylor', 'dirac']

def init():
    """Initializes the nomad inputs.

    This must be separate from main so that an error which occurs
    before the input file is created will be written to stdout.
    """

    process_arguments(sys.argv)

def process_arguments(args):
    """Process command line arguments."""
    global chkpt_file, prop_class, amp_archive, ti, tf
    global full_basis, t_method, t_step, init_method, int_method, int_order
    global tstep_methods, init_methods, int_methods

    glbl.paths['cwd']        = os.getcwd()
    glbl.paths['chkpt_file'] = args[1]
    chkpt_file               = args[1]

    if '-o' in sys.argv:
        amp_archive = str(args[args.index('-o')+1])
    else:
        amp_archive = 'amp_archive.hdf5'

    if '-ti' in sys.argv:
        ti = float(args[args.index('-ti')+1])
    else:
        ti = float(0.)

    if '-tf' in sys.argv:
        tf = float(args[args.index('-tf')+1])
    else:
        tf = None 

    if '-timestep' in sys.argv:
        t_step = float(args[args.index('-timestep')+1])
    else:
        t_step = 0.

    if '-propagate' in sys.argv:
        t_method = str(args[args.index('-propagate')+1])
        if t_method not in tstep_methods:
            sys.exit('time step method not recognized')
    else:
        t_method = 'nascent'

    if '-full_basis' in sys.argv:
        full_basis = True
    else:
        full_basis = False

    if '-initial_amps' in sys.argv:
        init_method = str(args[args.index('-initial_amps')+1])
        if init_method not in init_methods:
            sys.exit('initialization approach not recognized')
    else:
        init_method = 'overlap'

    if '-integrals' in sys.argv:
        int_method =  str(args[args.index('-integrals')+1])
        if int_method not in int_methods:
            sys.exit('integration scheme not recognized')
    else:
        int_method = 'taylor'        

    if '-integral_order' in sys.argv:
        int_order = int(args[args.index('-integral_order')+1])
    else:
        int_order = 1

    if '-ansatz' in sys.argv:
        prop_class = args[args.index('-ansatz')+1]
    else:
        prop_class = 'fms' 
 
    return

#
def main():
    """ main driver routine """
    global chkpt_file, prop_class, amp_archive, ti, tf
    global full_basis, t_step, t_method, init_method, int_method, int_order
    global tstep_methods, init_methods, int_methods

#    prop_classes = ['fms','mce','mca','ehrenfest']
    prop_classes = ['fms']

    if prop_class not in prop_classes:
        os.exit('prop_class='+prop_class+' is not a valid Hamiltonian type')

    # load the appropriate library
    prop_path = os.environ['NOMAD']+'/nomad/analysis/'+prop_class+'.so'
    ld_libs   = os.environ['LD_LIBRARY_PATH']
    if not os.path.isfile(prop_path):
        raise FileNotFoundError('Hamiltonian library not found: '+prop_path)
    lib_prop = ctypes.cdll.LoadLibrary(prop_path)

    # reset chkpt_file variable to be consistent with the current path
    chkpt = h5py.File(chkpt_file, 'r+', libver='latest')
    checkpoint.read_keywords(chkpt)

    # change the current default checkpoint file path to the checkpoint
     # file we're operating on.
    glbl.paths['chkpt_file'] = chkpt_file

    # pass the various run time options to the propagation library
    if t_step != 0:
        default_step = t_step
        step_method  = ['nascent', 'static'].index('static')+1
    else:
        default_step = float(glbl.properties['default_time_step'])
        step_method  = ['nascent', 'static'].index(t_method)+1
    init_method  = ['overlap', 'uniform', 'explicit'].index(init_method)+1
    int_method   = ['saddle', 'taylor', 'dirac'].index(int_method)+1 

    # initialize the trajectory table
    lib_utils.init_table(lib_prop, default_step, step_method)

    # initialize the table that holds trajectory amplitudes
    lib_utils.init_amplitudes(
                 lib_prop, default_step, step_method, init_method)   

    # initlize the propagation routines
    lib_utils.init_propagate(
                 lib_prop, full_basis, int_method, int_order)

    # create the trajectory table
    kwords = lib_utils.create_table(
                 lib_prop, chkpt)

    # load the trajectories into the table
    kwords = lib_utils.load_trajectories(
                 lib_prop, chkpt, kwords, ti, tf)
   
    # close the current checkpoint file 
    chkpt.close()

    # create the amplitude table
    lib_utils.create_amp_table(lib_prop, kwords)

    # after data is loaded, this is all on the propagation routines
    tstart = ti
    tend   = tf
    if tend is None:
        tend = kwords['tmax']

    lib_utils.propagate(lib_prop, tstart, tend)

    print("propagate complete")

    # once propagation is done, retrieve times, phase-space points and 
    # amplitudes from libprop
    glbl.paths['chkpt_file']          = amp_archive
    glbl.properties['store_matrices'] = True

    # this is temporary: only two options, fully coherent or fully incoherent
    # in the future: should be able to specify arbitrary groupings of initial
    # conditions
    nbatch = kwords['nbatch']
    if full_basis:
        nbatch = 1

    for ibat in range(nbatch):
        ibatch = ibat
        if full_basis:
            ibatch = -1 

        # retrieve the time-step info from the amplitude table
        time, n_traj, indices = lib_utils.amp_timestep_info(
                            lib_prop, True, ibatch, kwords['ntotal'])

        while n_traj>0:

            # retrieve a list of trajectories
            traj_list = lib_utils.traj_retrieve_timestep( 
                            lib_prop, kwords, indices, time, ibatch, n_traj)
            amp_list  = lib_utils.amp_retrieve_timestep(
                            lib_prop, indices)

            wfn      = wavefunction.Wavefunction()
            wfn.time = time
            for itraj in range(len(traj_list)):
                new_traj = traj_list[itraj]
                new_traj.update_amplitude(amp_list[itraj])

                # add trajectory to the wavefunction object
                wfn.add_trajectory(new_traj, relabel=False)

            # retrieve the matrices -- maybe useful for analysis
            mats = lib_utils.retrieve_matrices(lib_prop, time, ibatch, n_traj)
            wfn.update_matrices(mats)

            # throw this timestep to the new checkpoint file
            checkpoint.archive_simulation(wfn, None)

            # advance to the next time step
            max_step = lib_utils.amp_next_timestep(lib_prop, indices, n_traj)

            # if we've reached the maximum time step, we're done
            if max_step:
                n_traj = 0
            else:
                # get info on next time step
                time, n_traj, indices = lib_utils.amp_timestep_info(
                           lib_prop, False, ibatch, kwords['ntotal'])

    return

#   
if __name__ == '__main__':
    # parse command line arguments
    if '-openmp' in sys.argv:
        glbl.mpi['parallel'] = True

    # initialize
    init()

    # run the main routine
    main()

